buildscript {
  repositories {
    jcenter()
    maven {
      name = "Fabric"
      url = "http://maven.fabricmc.net/"
    }
    maven {
      name "Modmuss50 Repository"
      url 'https://maven.modmuss50.me'
    }
    maven {
      name = "Thiakil"
      url = "http://maven.thiakil.com"
    }
    mavenLocal()
  }
  dependencies {
    classpath "weave-asm:weave:0.1.0.+"
    classpath "commons-io:commons-io:1.4"
    classpath "com.google.guava:guava:19.0"
    classpath 'org.jetbrains.java.decompiler:FernFlower:43fec2e'
  }
}

def minecraft_version = "1.13-pre6"
def pomfVersion = "${minecraft_version}"

def ENV = System.getenv()

if (ENV.BUILD_NUMBER) {
  pomfVersion = pomfVersion + "." + "${System.getenv().BUILD_NUMBER}"
}

def mappingsDir = file("mappings")
def cacheFilesMinecraft = file(".gradle/minecraft")
def mergedFile = file("${minecraft_version}-merged.jar")
def versionFile = new File(cacheFilesMinecraft, "${minecraft_version}.json")
def clientJar = new File(cacheFilesMinecraft, "${minecraft_version}-client.jar")
def serverJar = new File(cacheFilesMinecraft, "${minecraft_version}-server.jar")



import com.google.common.hash.Hashing
import com.google.common.io.Files

import cuchaz.enigma.Deobfuscator
import cuchaz.enigma.TranslatingTypeLoader
import cuchaz.enigma.mapping.ClassMapping
import cuchaz.enigma.mapping.DirectionalTranslator
import cuchaz.enigma.mapping.MappingsEnigmaReader
import cuchaz.enigma.mapping.TranslationDirection
import cuchaz.enigma.mapping.entry.*
import groovy.json.JsonSlurper
import net.fabricmc.weave.CommandFindMappingErrors
import net.fabricmc.weave.CommandTinyify
import net.fabricmc.weave.merge.JarMerger
import org.apache.commons.io.FileUtils
import org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler
import org.objectweb.asm.ClassWriter
import org.objectweb.asm.tree.ClassNode

import java.util.jar.JarFile
import java.util.zip.GZIPOutputStream

boolean validateChecksum(File file, String checksum) {
  if (file != null) {
    def hash = Files.hash(file, Hashing.sha1())
    def builder = new StringBuilder()
    hash.asBytes().each {
      builder.append(Integer.toString((it & 0xFF) + 0x100, 16).substring(1))
    }
    return builder.toString().equals(checksum)
  }
  return false
}

task downloadVersionsManifest {
  //inputs.property "mc_ver", minecraft_version
  inputs.property "currenttime", new Date()
  def manifestFile = new File(cacheFilesMinecraft, "version_manifest.json")
  outputs.file(manifestFile)
  doLast {
    logger.lifecycle(":downloading minecraft versions manifest")
    FileUtils.copyURLToFile(new URL("https://launchermeta.mojang.com/mc/game/version_manifest.json"), manifestFile)
  }
}

def getManifestVersion(File manifestFile, String minecraft_version){
  def manifest = manifestFile.exists() ? new JsonSlurper().parseText(FileUtils.readFileToString(manifestFile)) : null
  return manifest != null ? manifest.versions.stream().filter({ it.id.equals(minecraft_version) }).findFirst() : java.util.Optional.empty()
}

task downloadWantedVersionManifest(dependsOn: downloadVersionsManifest){
  def manifestFile = downloadVersionsManifest.outputs.files.singleFile
  def manifestVersion = getManifestVersion(manifestFile, minecraft_version)

  //have to grab the release time as there's a current timestamp on each element?!
  inputs.property "releaseTime",  manifestVersion.isPresent() ? manifestVersion.get().releaseTime : -1

  outputs.file versionFile

  doLast {
    manifestVersion = getManifestVersion(manifestFile, minecraft_version)//nb need to re-read here in case it didn't exist before
    if (manifestVersion.isPresent() || versionFile.exists()) {

      if (manifestVersion.isPresent())
        FileUtils.copyURLToFile(new URL(manifestVersion.get().url), versionFile)
    } else {
      throw new RuntimeException("No version data for Minecraft version ${minecraft_version}")
    }
  }

}

task download(dependsOn: downloadWantedVersionManifest) {

  inputs.files versionFile

  outputs.files(clientJar, serverJar)

  outputs.upToDateWhen {
    def version = new JsonSlurper().parseText(FileUtils.readFileToString(versionFile))
    return clientJar.exists() && serverJar.exists() && validateChecksum(clientJar, version.downloads.client.sha1) && validateChecksum(serverJar, version.downloads.server.sha1)
  }

  doLast {
    if (!versionFile.exists()){
      throw new RuntimeException("Can't download the jars without the ${versionFile.name} file!")
    }

    //reload in case it changed
    def version = new JsonSlurper().parseText(FileUtils.readFileToString(versionFile))

    logger.lifecycle(":downloading minecraft jars")

    if (!clientJar.exists() || !validateChecksum(clientJar, version.downloads.client.sha1)) {
      logger.lifecycle(":downloading minecraft client")
      FileUtils.copyURLToFile(new URL(version.downloads.client.url), clientJar)
    }

    if (!serverJar.exists() || !validateChecksum(serverJar, version.downloads.server.sha1)) {
      logger.lifecycle(":downloading minecraft server")
      FileUtils.copyURLToFile(new URL(version.downloads.server.url), serverJar)
    }
  }
}

task mergeJars(dependsOn: download) {
  inputs.files download.outputs.files.files
  outputs.file(mergedFile)

  doLast {
    logger.lifecycle(":merging jars")
    def client = new FileInputStream(inputs.files.files.find {it.name.endsWith("-client.jar")})
    def server = new FileInputStream(inputs.files.files.find {it.name.endsWith("-server.jar")})
    def merged = new FileOutputStream(mergedFile)

    def jarMerger = new JarMerger(client, server, merged)
    jarMerger.merge()
    jarMerger.close()

    client.close()
    server.close()
    merged.close()
  }

}

task setupPomf (dependsOn: mergeJars) {

}

task pomf(dependsOn: setupPomf) {
  doLast {
    def cacheFilesEnigma = new File(".gradle/enigma")
    if (!cacheFilesEnigma.exists()) cacheFilesEnigma.mkdirs()

    def mavenMetadata = new File(cacheFilesEnigma, "maven-metadata.xml")
    def localEnigmaVersion = mavenMetadata.exists() ? new XmlSlurper().parseText(FileUtils.readFileToString(mavenMetadata)).versioning.release : ""

    logger.lifecycle(":downloading enigma metadata")
    FileUtils.copyURLToFile(new URL("http://maven.modmuss50.me/enigma-asm/enigma/maven-metadata.xml"), mavenMetadata)

    def metadata = new XmlSlurper().parseText(FileUtils.readFileToString(mavenMetadata))
    def enigmaVersion = metadata.versioning.release

    def enigma = new File(cacheFilesEnigma, "${enigmaVersion}.jar")

    if (localEnigmaVersion != enigmaVersion || !enigma.exists()) {
      logger.lifecycle(":downloading enigma")
      FileUtils.copyURLToFile(new URL("http://maven.modmuss50.me/enigma-asm/enigma/${enigmaVersion}/enigma-${enigmaVersion}-fat.jar"), enigma)
    } else {
      logger.lifecycle(":skipping enigma download")
    }

    logger.lifecycle(":launching enigma")
    ant.java(jar: enigma.getAbsolutePath(), fork: true, spawn: true) {
      arg(value: mergedFile.getAbsolutePath())
      arg(value: mappingsDir.getAbsolutePath())
    }
  }
}

task build(type: Zip) {
  from mappingsDir
  include "**/*"
  archiveName "pomf-enigma-${pomfVersion}.zip"
  destinationDir(file("build/libs"))
}

task checkMappings {
  inputs.dir mappingsDir
  doLast {
    logger.lifecycle(":checking mappings")

    String[] args = [
        mergedFile.getAbsolutePath(),
        mappingsDir.getAbsolutePath()
    ]

    new CommandFindMappingErrors().run(args)
  }
}

task buildTiny(dependsOn: "mergeJars") {
  inputs.dir mappingsDir
  def libs = new File("build/libs/")
  def outputFile = new File(libs, "pomf-tiny-${pomfVersion}.gz")
  outputs.file(outputFile)
  doLast {
    logger.lifecycle(":generating tiny mappings")

    String[] args = [
        mergedFile.getAbsolutePath(),
        mappingsDir.getAbsolutePath(),
        "mappings.tiny",
        "mojang",
        "pomf"
    ]

    new CommandTinyify().run(args)

    logger.lifecycle(":compressing tiny mappings")

    def buffer = new byte[1024]
    def fileOutputStream = new FileOutputStream(outputFile)
    def outputStream = new GZIPOutputStream(fileOutputStream)
    def inputFile = new File("mappings.tiny")
    def fileInputStream = new FileInputStream(inputFile)

    def length
    while ((length = fileInputStream.read(buffer)) > 0) {
      outputStream.write(buffer, 0, length)
    }

    fileInputStream.close()
    outputStream.finish()
    outputStream.close()
    inputFile.delete()
  }
}

tasks.build.dependsOn "buildTiny"

class CustomClassTransformer implements Deobfuscator.ClassTransformer {

  TranslatingTypeLoader loader;

  public CustomClassTransformer(TranslatingTypeLoader loader) {
    this.loader = loader;
  }

  @Override
  String transform(ClassNode node, ClassWriter writer) {
    return loader.transformInto(node, writer);
  }
}

class SpecialTranslator extends DirectionalTranslator {

  SpecialTranslator(DirectionalTranslator parent) {
    super(parent.direction, getClasses(parent), parent.translationIndex)
  }

  static Map<String, ClassMapping> getClasses(DirectionalTranslator t) {
    def field = DirectionalTranslator.class.getDeclaredField("classes")
    field.setAccessible(true)
    return (Map<String, ClassMapping>) field.get(t)
  }

  @Override
  ClassEntry getTranslatedClass(ClassEntry entry) {
    def result = super.getTranslatedClass(entry);
    if (isTypeEntry(result) && result.name.indexOf("/") == -1) {
      return new ClassEntry("unnamed/${result.name}");
    }
    return result
  }

  @Override
  ClassDefEntry getTranslatedClassDef(ClassDefEntry entry) {
    def result = super.getTranslatedClassDef(entry);
    if (isTypeEntry(result) && result.name.indexOf("/") == -1) {
      return new ClassDefEntry("unnamed/${result.name}", result.signature, result.access);
    }
    return result
  }

  static boolean isTypeEntry(ClassEntry entry) {
    return !entry.name.startsWith("[")
  }

  @Override
  MethodEntry getTranslatedMethod(MethodEntry entry) {
    def result = super.getTranslatedMethod(entry)
    if (result.name == "do") {
      return new MethodEntry(result.ownerClassEntry, "do_", result.desc)
    }
    return result
  }

  @Override
  MethodDefEntry getTranslatedMethodDef(MethodDefEntry entry) {
    def result = super.getTranslatedMethodDef(entry)
    if (result.name == "do") {
      return new MethodDefEntry(result.ownerClassEntry, "do_", result.desc, result.signature, result.access)
    }
    return result
  }

  @Override
  FieldEntry getTranslatedField(FieldEntry entry) {
    def result = super.getTranslatedField(entry)
    if (result.name == "do") {
      return new FieldEntry(result.ownerClassEntry, "do_", result.desc)
    }
    return result
  }

  @Override
  FieldDefEntry getTranslatedFieldDef(FieldDefEntry entry) {
    def result = super.getTranslatedFieldDef(entry)
    if (result.name == "do") {
      return new FieldDefEntry(result.ownerClassEntry, "do_", result.desc, result.signature, result.access)
    }
    return result
  }
}

task mapJar(dependsOn: mergeJars) {
  inputs.file mergedFile
  inputs.dir file("mappings")
  outputs.file file(mergedFile.name.replace(".jar", "-mapped.jar"))

  doLast {
    def deobfuscator = new Deobfuscator(new JarFile(mergedFile));
    deobfuscator.setMappings(new MappingsEnigmaReader().read(file("mappings")));
    def obfTranslator = deobfuscator.getTranslator(TranslationDirection.OBFUSCATING)
    def deobfTranslator = new SpecialTranslator((DirectionalTranslator) deobfuscator.getTranslator(TranslationDirection.DEOBFUSCATING))
    TranslatingTypeLoader loader = new TranslatingTypeLoader(deobfuscator.getJar(), deobfuscator.getJarIndex(), new ReferencedEntryPool(), obfTranslator, deobfTranslator);
    deobfuscator.transformJar(outputs.files.singleFile, null, new CustomClassTransformer(loader));
  }
}

task decompMapped(dependsOn: mapJar) {
  inputs.file tasks.mapJar.outputs.files.singleFile
  outputs.file file(mergedFile.name.replace(".jar", "-sources.jar"))

  doLast {
    def cacheFilesDecomp = file(".gradle/decompCache")
    cacheFilesDecomp.mkdirs()
    ConsoleDecompiler.main((String[]) [
        "-dgs=true",
        "-rbr=true",
        "-jvn=1",
        "-sef=1",
        "-log=warn",
        "-ind=\t",
        "-rsy=1",
        inputs.files.singleFile.toString(),
        cacheFilesDecomp.toString()
    ])
    def decompFile = new File(cacheFilesDecomp, getInputs().files.singleFile.getName())
    def destFile = outputs.files.singleFile
    if (destFile.exists())
      destFile.delete()
    decompFile.renameTo(destFile)
  }
}

task extractDecomp(dependsOn: decompMapped, type: Sync) {
  from zipTree(tasks.decompMapped.outputs.files.singleFile)
  into file("decomp/src/main/java/")
}
