buildscript {
  repositories {
    jcenter()
    maven {
      name = "Fabric"
      url = "http://maven.fabricmc.net/"
    }
    maven {
      name "Modmuss50 Repository"
      url 'https://maven.modmuss50.me'
    }
    maven {
      name = "Thiakil"
      url = "http://maven.thiakil.com"
    }
    mavenLocal()
  }
  dependencies {
    classpath "net.fabricmc:weave:+"
    classpath "commons-io:commons-io:1.4"
    classpath "com.google.guava:guava:19.0"
    classpath 'org.jetbrains.java.decompiler:FernFlower:43fec2e'
  }
}

def minecraft_version = "1.13-pre5"
def pomfVersion = "${minecraft_version}"

def ENV = System.getenv()

if (ENV.BUILD_NUMBER) {
  pomfVersion = pomfVersion + "." + "${System.getenv().BUILD_NUMBER}"
}

def mappingsDir = file("mappings")
def cacheFilesMinecraft = file(".gradle/minecraft")
def mergedFile = file("${minecraft_version}-merged.jar")
def versionFile = new File(cacheFilesMinecraft, "${minecraft_version}.json")
def clientJar = new File(cacheFilesMinecraft, "${minecraft_version}-client.jar")
def serverJar = new File(cacheFilesMinecraft, "${minecraft_version}-server.jar")

import com.google.common.hash.Hashing
import com.google.common.io.Files
import cuchaz.enigma.Deobfuscator
import cuchaz.enigma.TranslatingTypeLoader
import cuchaz.enigma.mapping.ClassEntry
import cuchaz.enigma.mapping.ClassMapping
import cuchaz.enigma.mapping.FieldEntry
import cuchaz.enigma.mapping.MappingsEnigmaReader
import cuchaz.enigma.mapping.MethodEntry
import cuchaz.enigma.mapping.TranslationDirection
import cuchaz.enigma.mapping.Translator
import groovy.json.JsonSlurper
import javassist.CtClass
import net.fabricmc.weave.CommandFindMappingErrors
import net.fabricmc.weave.CommandTinyify
import net.fabricmc.weave.merge.JarMerger
import org.apache.commons.io.FileUtils

import java.util.zip.GZIPOutputStream

boolean validateChecksum(File file, String checksum) {
  if (file != null) {
    def hash = Files.hash(file, Hashing.sha1())
    def builder = new StringBuilder()
    hash.asBytes().each {
      builder.append(Integer.toString((it & 0xFF) + 0x100, 16).substring(1))
    }
    return builder.toString().equals(checksum)
  }
  return false
}

task downloadVersionsManifest {
  //inputs.property "mc_ver", minecraft_version
  inputs.property "currenttime", new Date()
  def manifestFile = new File(cacheFilesMinecraft, "version_manifest.json")
  outputs.file(manifestFile)
  doLast {
    logger.lifecycle(":downloading minecraft versions manifest")
    FileUtils.copyURLToFile(new URL("https://launchermeta.mojang.com/mc/game/version_manifest.json"), manifestFile)
  }
}

def getManifestVersion(File manifestFile, String minecraft_version){
  def manifest = manifestFile.exists() ? new JsonSlurper().parseText(FileUtils.readFileToString(manifestFile)) : null
  return manifest != null ? manifest.versions.stream().filter({ it.id.equals(minecraft_version) }).findFirst() : java.util.Optional.empty()
}

task downloadWantedVersionManifest(dependsOn: downloadVersionsManifest){
  def manifestFile = downloadVersionsManifest.outputs.files.singleFile
  def manifestVersion = getManifestVersion(manifestFile, minecraft_version)

  //have to grab the release time as there's a current timestamp on each element?!
  inputs.property "releaseTime",  manifestVersion.isPresent() ? manifestVersion.get().releaseTime : -1

  outputs.file versionFile

  doLast {
    manifestVersion = getManifestVersion(manifestFile, minecraft_version)//nb need to re-read here in case it didn't exist before
    if (manifestVersion.isPresent() || versionFile.exists()) {

      if (manifestVersion.isPresent())
        FileUtils.copyURLToFile(new URL(manifestVersion.get().url), versionFile)
    } else {
      throw new RuntimeException("No version data for Minecraft version ${minecraft_version}")
    }
  }

}

task download(dependsOn: downloadWantedVersionManifest) {

  inputs.files versionFile

  outputs.files(clientJar, serverJar)

  outputs.upToDateWhen {
    def version = new JsonSlurper().parseText(FileUtils.readFileToString(versionFile))
    return clientJar.exists() && serverJar.exists() && validateChecksum(clientJar, version.downloads.client.sha1) && validateChecksum(serverJar, version.downloads.server.sha1)
  }

  doLast {
    if (!versionFile.exists()){
      throw new RuntimeException("Can't download the jars without the ${versionFile.name} file!")
    }

    //reload in case it changed
    def version = new JsonSlurper().parseText(FileUtils.readFileToString(versionFile))

    logger.lifecycle(":downloading minecraft jars")

    if (!clientJar.exists() || !validateChecksum(clientJar, version.downloads.client.sha1)) {
      logger.lifecycle(":downloading minecraft client")
      FileUtils.copyURLToFile(new URL(version.downloads.client.url), clientJar)
    }

    if (!serverJar.exists() || !validateChecksum(serverJar, version.downloads.server.sha1)) {
      logger.lifecycle(":downloading minecraft server")
      FileUtils.copyURLToFile(new URL(version.downloads.server.url), serverJar)
    }
  }
}

task mergeJars(dependsOn: download) {
  inputs.files download.outputs.files.files
  outputs.file(mergedFile)

  doLast {
    logger.lifecycle(":merging jars")
    def client = new FileInputStream(inputs.files.files.find {it.name.endsWith("-client.jar")})
    def server = new FileInputStream(inputs.files.files.find {it.name.endsWith("-server.jar")})
    def merged = new FileOutputStream(mergedFile)

    def jarMerger = new JarMerger(client, server, merged)
    jarMerger.merge()
    jarMerger.close()

    client.close()
    server.close()
    merged.close()
  }

}

task setupPomf (dependsOn: mergeJars) {

}

task pomf(dependsOn: setupPomf) {
  doLast {
    def cacheFilesEnigma = new File(".gradle/enigma")
    if (!cacheFilesEnigma.exists()) cacheFilesEnigma.mkdirs()

    def mavenMetadata = new File(cacheFilesEnigma, "maven-metadata.xml")
    def localEnigmaVersion = mavenMetadata.exists() ? new XmlSlurper().parseText(FileUtils.readFileToString(mavenMetadata)).versioning.release : ""

    logger.lifecycle(":downloading enigma metadata")
    FileUtils.copyURLToFile(new URL("http://maven.modmuss50.me/enigma-asm/enigma/maven-metadata.xml"), mavenMetadata)

    def metadata = new XmlSlurper().parseText(FileUtils.readFileToString(mavenMetadata))
    def enigmaVersion = metadata.versioning.release

    def enigma = new File(cacheFilesEnigma, "${enigmaVersion}.jar")

    if (localEnigmaVersion != enigmaVersion || !enigma.exists()) {
      logger.lifecycle(":downloading enigma")
      FileUtils.copyURLToFile(new URL("http://maven.modmuss50.me/enigma-asm/enigma/${enigmaVersion}/enigma-${enigmaVersion}-fat.jar"), enigma)
    } else {
      logger.lifecycle(":skipping enigma download")
    }

    logger.lifecycle(":launching enigma")
    ant.java(jar: enigma.getAbsolutePath(), fork: true, spawn: true) {
      arg(value: mergedFile.getAbsolutePath())
      arg(value: mappingsDir.getAbsolutePath())
    }
  }
}

task build(type: Zip) {
  from mappingsDir
  include "**/*"
  archiveName "pomf-enigma-${pomfVersion}.zip"
  destinationDir(file("build/libs"))
}

task checkMappings {
  inputs.dir mappingsDir
  doLast {
    logger.lifecycle(":checking mappings")

    String[] args = [
            mergedFile.getAbsolutePath(),
            mappingsDir.getAbsolutePath()
    ]

    new CommandFindMappingErrors().run(args)
  }
}

task buildTiny(dependsOn: "mergeJars") {
  inputs.dir mappingsDir
  def libs = new File("build/libs/")
  def outputFile = new File(libs, "pomf-tiny-${pomfVersion}.gz")
  outputs.file(outputFile)
  doLast {
    logger.lifecycle(":generating tiny mappings")

    String[] args = [
            mergedFile.getAbsolutePath(),
            mappingsDir.getAbsolutePath(),
            "mappings.tiny",
            "mojang",
            "pomf"
    ]

    new CommandTinyify().run(args)

    logger.lifecycle(":compressing tiny mappings")

    def buffer = new byte[1024]
    def fileOutputStream = new FileOutputStream(outputFile)
    def outputStream = new GZIPOutputStream(fileOutputStream)
    def inputFile = new File("mappings.tiny")
    def fileInputStream = new FileInputStream(inputFile)

    def length
    while ((length = fileInputStream.read(buffer)) > 0) {
      outputStream.write(buffer, 0, length)
    }

    fileInputStream.close()
    outputStream.finish()
    outputStream.close()
    inputFile.delete()
  }
}

tasks.build.dependsOn "buildTiny"

class CustomClassTransformer implements Deobfuscator.ClassTransformer {

  TranslatingTypeLoader loader;

  public CustomClassTransformer(TranslatingTypeLoader loader) {
    this.loader = loader;
  }

  @Override
  public CtClass transform(CtClass ctClass) throws Exception {
    return loader.transformClass(ctClass);
  }
}

class SpecialTranslator extends Translator{

  SpecialTranslator(Translator parent){
    super(parent.direction, getClasses(parent), parent.translationIndex)
  }

  static Map<String, ClassMapping> getClasses(Translator t){
    def field = Translator.class.getDeclaredField("classes")
    field.setAccessible(true)
    return (Map<String, ClassMapping>)field.get(t)
  }

  @Override
  ClassEntry translateEntry(ClassEntry classEntry) {
    def result = super.translateEntry(classEntry)
    if (result.getName().indexOf("/") == -1){
      return new ClassEntry("unnamed/"+result.getName())
    }
    return result
  }

  @Override
  String translate(MethodEntry entry) {
    def result = super.translate(entry)
    if (result == null && entry.getName() == "do"){
      return "do_"
    }
    return result
  }

  @Override
  String translate(FieldEntry entry) {
    def result = super.translate(entry)
    if (result == null && entry.getName() == "do"){
      return "do_"
    }
    return result
  }
}

task mapJar(dependsOn: mergeJars){
  inputs.file mergedFile
  inputs.dir file("mappings")
  outputs.file file(mergedFile.name.replace(".jar", "-mapped.jar"))

  doLast {
    def deobfuscator = new Deobfuscator(new JarFile(mergedFile));
    deobfuscator.setMappings(new MappingsEnigmaReader().read(file("mappings")));
    TranslatingTypeLoader loader = new TranslatingTypeLoader(deobfuscator.getJar(), deobfuscator.getJarIndex(), deobfuscator.getTranslator(TranslationDirection.Obfuscating), new SpecialTranslator(deobfuscator.getTranslator(TranslationDirection.Deobfuscating)));
    deobfuscator.transformJar(outputs.files.singleFile, null, new CustomClassTransformer(loader));
  }
}

import org.objectweb.asm.FieldVisitor
import org.objectweb.asm.MethodVisitor

import java.util.jar.JarFile
import java.util.jar.JarOutputStream
import java.util.regex.Pattern
import java.util.zip.ZipEntry;
import org.objectweb.asm.ClassReader
import org.objectweb.asm.ClassVisitor
import org.objectweb.asm.ClassWriter
import org.objectweb.asm.Opcodes

static def pipe(InputStream is, OutputStream os){
  try {
    int n;
    byte[] buffer = new byte[1024];
    while ((n = is.read(buffer)) > -1) {
      os.write(buffer, 0, n);   // Don't allow any extra bytes to creep in, final write
    }
    //os.close ();
    is.close()
  } catch (IOException e){
    throw new RuntimeException(e)
  }
}

class Visitor extends ClassVisitor{
  static Pattern objectPattern = Pattern.compile(".*:Ljava/lang/Object;:.*");

  public Visitor(ClassVisitor cv){
    super(Opcodes.ASM5, cv);
  }

  private String getFixedSignature(String signature){
    if (signature != null && objectPattern.matcher(signature).matches()){
      signature = signature.replaceAll(":Ljava/lang/Object;:", "::")
    }
    return signature;
  }

  @Override
  void visit(int version, int access, String name, String signature, String superName, String[] interfaces) {
    super.visit(version, access, name, getFixedSignature(signature), superName, interfaces)
  }

  @Override
  MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) {
    return super.visitMethod(access, name, desc, getFixedSignature(signature), exceptions)
  }

  @Override
  FieldVisitor visitField(int access, String name, String desc, String signature, Object value) {
    return super.visitField(access, name, desc, getFixedSignature(signature), value)
  }
}

task fixGenerics {
  doLast {
    def mappedJar = tasks.mapJar.outputs.files.singleFile
    if (mappedJar.exists()){
      logger.lifecycle("Fixing generics in ${mappedJar.absolutePath}")
      def tmpFile = new File(mappedJar.parentFile, mappedJar.name+".tmp")
      if (tmpFile.exists())
        tmpFile.delete()
      if (!mappedJar.renameTo(tmpFile)){
        throw new RuntimeException("Couldnt rename ${mappedJar.absolutePath} to ${tmpFile.absolutePath}")
      }
      def jarIn = new JarFile(tmpFile)
      def jarOut = new JarOutputStream(new FileOutputStream(mappedJar));
      /*def jarIn = new JarFile(mappedJar)
      def jarOut = new JarOutputStream(new FileOutputStream(tmpFile));*/
      jarIn.stream().forEach({ entry->
        if (!entry.name.endsWith(".class")){
          try {
            jarOut.putNextEntry(new ZipEntry(entry))
          } catch (IOException e){
            throw new RuntimeException(e)
          }
          pipe(jarIn.getInputStream(entry), jarOut)
        } else {
          InputStream clazzIn = jarIn.getInputStream(entry)
          ClassReader reader = new ClassReader(clazzIn)
          ClassWriter cw = new ClassWriter(0)
          reader.accept(new Visitor(cw), 0)
          try {
            jarOut.putNextEntry(new ZipEntry(entry.name))
          } catch (IOException e){
            throw new RuntimeException(e)
          }
          pipe(new ByteArrayInputStream(cw.toByteArray()), jarOut)
        }
      })
      jarOut.close()
      jarIn.close()
      tmpFile.delete()
    }
  }
}

mapJar.finalizedBy(fixGenerics)

task decompMapped(dependsOn: mapJar) {
  inputs.file tasks.mapJar.outputs.files.singleFile
  outputs.file file(mergedFile.name.replace(".jar", "-sources.jar"))

  doLast {
    def cacheFilesDecomp = file(".gradle/decompCache")
    cacheFilesDecomp.mkdirs()
    org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler.main((String[]) [
            "-dgs=true",
            "-rbr=true",
            "-jvn=1",
            "-sef=1",
            "-log=warn",
            inputs.files.singleFile.toString(),
            cacheFilesDecomp.toString()
    ])
    def decompFile = new File(cacheFilesDecomp, getInputs().files.singleFile.getName())
    def destFile = outputs.files.singleFile
    if (destFile.exists())
      destFile.delete()
    decompFile.renameTo(destFile)
  }
}

task extractDecomp(dependsOn: decompMapped, type: Sync){
  from zipTree(tasks.decompMapped.outputs.files.singleFile)
  into file("decomp/src/main/java/")
}